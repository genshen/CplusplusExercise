Problems: [README.md](README.md)
### 选择题
1. 答案：B
解析：经过编辑、编译、连接和运行四个步骤。编辑是将C++源程序输入计算机的过程，保存文件名为cpp。编译是用编译器将多个源程序cpp文件编译成多个单独的目标文件，最后通过连接将多个目标文件连接成一个可执行文件，最后运行可执行文件。

2. 答案：D
解析：函数的返回值类型由定义函数时的指定的数据类型决定的。A项的表达式的值要转换

3. 答案: D
解析：继承方式有三种：公有、私有和保护。多继承中，多个基类具有同名成员，在它们的子类中访问这些成员，就产生了二义性，但进行访问时，不能存在二义性。赋值兼容规则是指派生类对象可以当作基类对象使用，只要存在继承关系，所以单继承或多继承都适用。基类中的公有成员采用私有继承时，在派生类中变成了私有成员，所以D项错误。

4. 答案：A
解析：类即数据和操作的组合体，数据是类的静态特征，操作是类具有的动作。

5. 答案：A
解析：在派生类中基类的保护或者基类公有都可以直接访问，基类的私有成员只能是基类的成员函数来访问。所以选择A项。

6. 答案：B
解析：派生类的成员一个是来自基类，一个来自本身，所以派生类是基类的扩展，也是基类的具体化和特殊化，派生类是对基类扩展。B项基类不能继承派生类成员，所以错误。

7. 答案：A
解析：this指针是隐藏的，可以使用该指针来访问调用对象中的数据。基类的成员在派生类中能否访问，与继承方式有关，与this没有关系。所以选择A项。

8. 答案：B
解析：多态性有两种静态多态性和动态多态性，静态多态性是指调用同名函数，由于参数的不同调用不同的同名函数；动态多态性是指不同对象调用同名函数时，由于对象不同调用不同的同名函数。 多态性肯定具有相同的函数名，所以选择B项。

9. 答案：A
解析：内联函数特征代码少，频繁调用，执行效率高。重载函数解决统一接口的问题；递归是子程序调用，程序调用要耗费很多空间和时间，循环/迭代都比递归有效率得多，递归只是从形式上，逻辑比较简洁。嵌套函数即反复调用，速度较慢。所以选择A项。
再多说一点：我们通过inline关键字来请求编译器再编译时进行“内联展开”(即再内联函数调用的地方，用函数题代替函数的调用。)，但是否会进行“内联展开”由编译器决定。内联函数的优点是减少了函数调用的开销，缺点是可能会使生成的代码文件变大。

10. else 悬垂问题：else和最近的if或者else if匹配(参见12.16日/周五晚ppt)

11. 答案：A
解析：派生类构造函数必须对这三类成员进行初始化，其执行顺序：调用基类构造函数；调用子对象的构造函数；派生类的构造函数体。析构函数在执行过程中也要对基类和成员对象进行操作，但它的执行过程与构造函数正好相反，即对派生类新增普通成员进行清理；调用成员对象析构函数，对派生类新增的成员对象进行清理；调用基类析构函数，对基类进行清理，所以选择A项。

12. 答案：C
解析：内联函数具有程序代码少、频繁调用和执行效率高的特征，所以选择C项

13. 答案：C
解析：a=4,因为后减，b的值与a、bb相关，b＝4*5=20，而与aa没有任何关系。

14. 答案：A
解析：extern用于声明外部变量的。register声明寄存器类型变量。无cpu类型。它们都不能声明类成员。public声明为公有访问权限，所以选择A项。

15. 答案：B
解析：类的定义，如果有自身类对象，使得循环定义，B项错误。在类中具有自身类的指针，可以实现链表的操作，当然也可以使用对象的引用。类中可以有另一个类的对象，即成员对象。所以选择B选项。

16. 答案：D
解析：地址作为实参，表示实参与形参都指向同一个对象。如果实参是数值，形参也是普通变量，此时形参是实参的拷贝，再内存上不是同一对象。所以选择D项。

17. 答案：B
解析：如果数组元素都是相同类型的指针，则称这个数组为指针数组。指针数组一般用于处理二维数组。声明的格式为：<数据类型><(*变量名)><［元素个数］>。
p表示指向数组n的行指针。如果将指针的初始化(*p)［3］=b;地址的等价形式：
p+i p［i］*(p+i)都表示b数组第i+1行的第1个元素的首地址。
*(p+i)+jp［i］+j &p［i］［j］都表示b数组第i+1行、第j+1列元素的地址。
值的等价形式：
*(*(p+i)+j) *(p［i］+j) p［i］［j］都表示b数组第i+1、第j+1列元素的值。
所以题目分别访问p［0］［0］，p［0］［1］，p［0］［2］。

18. 答案：A
解析：(1)标准输入流cin：istream类的对象。(2)标准输出流cout：ostream类的对象。
(3)非缓冲型标准出错流cerr：ostream类的对象。(4)缓冲型标准出错流clog：ostream类的对象

19. 答案：B
解析：对象访问成员的方式为：对象名.成员。指针可以有两种：(*对象指针).成员或者对象指针->成员。A选项是访问数据成员，B项是访问成员函数。

20. 答案：A
解析：A对象在C＋＋中才有，包括数据和操作两项，而C中的变量只有数据，没有操作。所以A项错误。

### 填空题
1. 答案：cerr
 [解析]cin、cout、clog和cerr分别用于标准输入、输出、标准错误流（缓冲）和标准错误流
（非缓冲）。

2. 答案：实例
 [解析]类是对象的抽象，对象是类的一个实例。

3. 答案：int *ip=new int［10］;
 [解析]new用来动态开辟空间。常用来产生动态数组及对象构造函数。

4. 答案：指向一个数组的指针，这个数组的长度为10，元素类型为int类型。
 [解析]注：注意：int *p[10] 和 int (*p)[10]的区别，前者表示的是一个长度为10的数组，数组元素类型是int 类型的指针。

5. 答案：无参
 [解析]使用new创建对象数组，调用无参构造函数。

6. 答案：'＼n'
 [解析]endl与字符常量'＼n'等价。

7. 答案：->
 [解析]指针使用成员有两种方法：“->”指向运算符和“.”成员访问运算符。

8. 答案：复制或拷贝
 [解析]复制或拷贝构造函数就是用对象初始化新的对象。

9. 答案:类成员
 [解析]运算符重载的方法有友元或者成员函数两种途径，但是赋值运算符只能使用成员函数的方法来实现。

10. 答案：friend void A::f()；
 [解析]成员函数作为另一个类的友元函数，格式为：friend 返回类型 类名::函数(形参)。

11. 答案：4
 [解析]for循环结构,三个表达式的作用，初始化、循环判断条件和循环变量变化。循环执行了三次，k的作用是计算i、j的和。

12. 答案：find
 [解析]string类对象方法的find，查不到字符串，则返回-1。

13. 答案：无限次
 [解析]＝是赋值运算符，不是关系运算符，赋值运算的结果是等号左边的对象，而每次赋值，等号左边对象n的值一直是1（非0），所以while处的判断结果是true,循环会一直持续下去，除非终止程序或其他异常情况发生。

14. 答案：数组a的第二行第三列的那个元素。
 [解析]假如：int a[3][4] = {{1, 2, 3, 4},{2, 2, 3, 4},{3, 2, 3, 4}};

    a[2] 	第二行那个内层数组{2，2，3，4}
    a+2	     指向第二行那个内层数组{2，2，3，4}的指针
    *(a+2)	 a[2]或者说是指向内层数组首元素的指针
    *(a+2)+3	指向第二行第三列那个int型数据的指针
    *(*(a+2)+3)	a[2][3]
    *(a[2]+3)	a[2][3]
    *(a+2)[3]	a[2][3]


15. 运行时
 [解析]多态性包括静态的（编译时）多态性和动态的（运行时）多态性。

16. 答案：形参列表不相同(或回答：形参个数不相同或者形参类型不一一对应)
 [解析]函数重载的条件是，函数名相同，但形参不同（形参不同体现再形参个数不同或形参类型不一一对应）

17. 答案： C++
 [解析]substr取子字符串，第1个参数表示要截取子串在字符串中的位置，第2个表示取多少个字符。

18. 答案：类
 [解析]类是相似特征的对象的抽象，对象是类的一个实例。

19. 答案：无参构造函数
 [解析]使用new 创建动态对象数组，不能有参数，所以只能调用无参的构造函数，初始化对象。

20. 答案：int (*fp)(int , int) = &max; 或int (*fp)(int , int) = max;

### 改错题：
1. 答案：int x,y=20;在类内部不能对数据成员直接赋值。
 [修改]int x,y;

2. int i,int j调用时，既有一个参数，也有两个参数，且没有重载，所以参数需要带默认值。所以int i,int j错误。
 [修改] int i,int j＝0//注j只要有一个int类型的数据就行。

3. 答案：将malloc的第一个参数改为指针的引用。
 [修改]void malloc(int *&p, int length)
 [解析]为了方便表述，设malloc函数的第一个形参的名字叫p’。
 除了引用外，指针和普通的对象再进行参数传递时都是值传递，所以p’是main函数中指针p的拷贝。p’ 和p在内存里面是存在于两个地方的，而且，特别地，在执行new语句前，他们都不指向任何对象。执行new语句后，p’指向新申请的内存空间，而p仍然不指向任何对象。所以函数调用结束后，p仍然不指向任何对象，自然main函数中后面对通过p指针访问数组是没办法实现的。
 所以，修改的办法很简单，就算将指针的值传递改为引用，这时，p’只是p的别名，p’指向新内存空间就是p指向新内存空间。

4. 答案：cout<<this->x=x<<endl;要输出this->x=x表达式的值要加括号。
 [修改] cout<<（this->x=x）<<endl;

5. void show();是普通函数不是成员函数，但是要访问类成员，需要定义为友元函数。
 [修改]friend void show();

### 代码填空题：
1. 答案：Char[ch-65-6]++;
 [解析]此处应该是处理小写字母，使其频率增加1。通过程序，可以看出Char数组中存的是各个字母出现的频率，其中Char[0]是’A’的频率，Char[1]存的是‘B’的频率,…Char[25]是’Z’的频率, Char[26]是’a’的频率, Char[27]是’b’的频率,…, Char[51]是’z’的频率.

2. 答案：static int x;,int Test::x=30;
 [解析]从成员函数访问方式类名：：成员可知是静态成员所以static int x;从结果要对初始化为30，且在类外进行初始化， int Test::x=30;

3. 答案：operator+(Magic&c),friend ostream&operator
 [解析]对加法进行重载，operator+(Magic & c)，是对插入符进行重载，要访问成员所以定义为友元函数，friend ostream & operator。

4. 答案：using namespace std,#define pi 3.14159
 [解析]进行输入或输出要引入iostream, 所以using namespace std;从标点看没有分号，所以使用宏定义，#define pi 3.14159。

5. 答案：int i=32;，a>=A && a<=Z
 [解析]大写字母变小写字母相差32，需要对i声明并初始化。大写字母变小写字母。要判断字符是大写字母。

### 程序分析题：
1. 答案：
［解析］此题代码的功能是二分查找算法的实现，如果欲查找的整数存在，则返回与其匹配的数组下标(需要注意，有多个目标存在时的情况)；否则返回-1
    ```
    8
    -1
    ```

2. 答案：11 13 17 19 23 29
［解析］循环体用来判断n是否是质数的函数,在main函数判断10～30之间质数。

3. 答案：
   ```
    结果:姓名成绩等级
    张三78中
    李四92优
    王五62及格
    孙六88良
    
    ```
### 程序设计题
1. 代码如下：
 ```
 class Rectangle : public Shape {
    public:
        Rectangle(float i, float j) : L(i), W(j) {}
        ~Rectangle() {}
        float GetPerim() { return 2 * (L + W); }

    private:
        float L, W;
    };

    class Circle : public Shape {
    public:
        Circle(float r) : R(r) {}

        float GetPerim() { return 3.14 * 2 * R; }

    private:
        float R;
    };

    void main() {
        Shape *sp;
        sp = new Circle(10);
        cout << sp->GetPerim() << endl;
        sp = new Rectangle(6, 4);
        cout << sp->GetPerim() << endl;
    }

 ```

2. 参见周五(12.16日)晚ppt函数指针部分例子.